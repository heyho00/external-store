# usestore-ts

ReduxStore에서 기반이 되는 BaseStore를 따로 빼줬던 것처럼

CounterStore에서도 변하지 않는 부분, 중복이 되는 부분, 기반이 되는 ObjectStore로 나눠보자.

```js
// import { singleton } from "tsyringe"; 삭제

type Listener = () => void;

// @singleton() 삭제
export default class ObjectStore {
//   count = 0;

  private listeners = new Set<Listener>();
    //listeners도 private으로


// 삭제 !!!!
//   increase() {
//     this.count += 1;
//     this.publish();
//   }

//   decrease() {
//     this.count -= 1;
//     this.publish();
//   }

  addListener(listener: Listener) {
    this.listeners.add(listener);
  }

  removeListener(listener: Listener) {
    this.listeners.delete(listener);
  }

  protected publish() { // ReduxStore에서도 해줬어야 하는데 안해줌. 딴데서 쓰지 못하게 protected 붙여준다.
    this.listeners.forEach((listener) => listener());
  }
}

```

얘를 상속받아 쓴다.

```js
import { singleton } from "tsyringe";
import ObjectStore from "./ObjectStore";

// type Listener = () => void; 삭제

@singleton()
export default class CounterStore extends ObjectStore {
  count = 0;

  // 삭제
  //   listeners = new Set<Listener>();

  //   publish() {
  //     this.listeners.forEach((listener) => {
  //       listener();
  //     });
  //   }

  increase() {
    this.count += 1;
    this.publish();
  }

  decrease() {
    this.count -= 1;
    this.publish();
  }

  // 삭제
  //   addListener(listener: Listener) {
  //     this.listeners.add(listener);
  //   }

  //   removeListener(listener: Listener) {
  //     this.listeners.delete(listener);
  //   }
}
```

중복을 제거하고 increase, decrease에만 집중할 수 있다.

Redux 따라하기에서는

Redux를 따라하려다 보니 단일 스토어로 만들어

useSelector를 이용해 state를 꺼내 썼는데

이번엔 스토어를 여러개 만들어 쓰는 컨셉.

useSelector를 Counter에서 우선 없앤다.

```js
// Counter.tsx

import useSelector from "../hooks/useSelector";

export default function Counter() {
  //   const count = useSelector((state) => state.count);
  const store = useCounterStore();

  return (
    <>
      // <div>Count: {count}</div>
      <div>Count: {store.count}</div>
    </>
  );
}
```

useCounterStore에서 또 중복을 제거해서 기반이 되는 useObjectStore를 만든다.

```js
import { container } from "tsyringe";
import CounterStore from "../stores/Store";
import useForceUpdate from "../hooks/useForceUpdate";
import { useEffect } from "react";
import ObjectStore from "../stores/ObjectStore";

//--------------------------------------------------------
function useObjectStore(store: ObjectStore) {
  //여기
  const forceUpdate = useForceUpdate();

  useEffect(() => {
    store.addListener(forceUpdate);

    return () => {
      store.removeListener(forceUpdate);
    };
  }, [store, forceUpdate]);
}

// 이것도 따로 파일 빼준다
//--------------------------------------------------------

export default function useCounterStore(): CounterStore {
  //여기
  const store = container.resolve(CounterStore);

  // 위로 뺌
  //   const forceUpdate = useForceUpdate();

  //   useEffect(() => {
  //     store.addListener(forceUpdate);

  //     return () => {
  //       store.removeListener(forceUpdate);
  //     };
  //   }, [store, forceUpdate]);

  return useObjectStore(store);
}
```

'여기' 부분을보면 타입이 안맞아 에러남.

제네릭으로 타입을 잡아준다.

아무거나 받을 순 있는데, ObjectStore 상속받은 애여야해, 연진아

```js
.
.
.
function useObjectStore<T extends ObjectStore>(store: T): T {
.
.
.

```

문제가 없으니 useCounterStore 타이핑 지워준다.

타입 안맞는거 보여주려고 한거라 함.

```js
// export default function useCounterStore(): CounterStore {
export default function useCounterStore() {
  const store = container.resolve(CounterStore);

  return useObjectStore(store);
}
```

CountControl.tsx도 복잡하게 했었는데 이러고 싶었어

```js
// CountControl.tsx

// import useDispatch from "../hooks/useDispatch";
// import useSelector from "../hooks/useSelector";
// import { decrease, increase } from "../stores/ReduxStore";

import useCounterStore from "../hooks/useCounterStore";

export default function CountControl() {
//   const dispatch = useDispatch();
    const store = useCounterStore();
    const {count} = store

//   const count = useSelector((state) => state.count);

  return (
    <>
      <p>{count}</p>
      // <button type="button" onClick={() => dispatch(increase())}>
      <button type="button" onClick={() => store.increase()}>
        Increase
      </button>

      // <button type="button" onClick={() => dispatch(increase(10))}>
      <button type="button" onClick={() => store.increase(10)}>
        Increase 10
      </button>

      // <button type="button" onClick={() => store.decrease()}>
      <button type="button" onClick={() => dispatch(decrease())}>
        Decrease
      </button>

      // <button type="button" onClick={() => store.decrease(10)}>
      <button type="button" onClick={() => dispatch(decrease(10))}>
        Decrease 10
      </button>
    </>
  );
}
```

취향의 차이기도 하고 다른 차이도 있다.

메서드 스타일로 쓰면 자동완성의 힘을 더 빌릴 수 있다.

CounterStore 에도 step을 처리하도록 만들어준다.

```js
import { singleton } from "tsyringe";
import ObjectStore from "./ObjectStore";

@singleton()
export default class CounterStore extends ObjectStore {
  count = 0;

  //   increase() {
  //     this.count += 1;
  //     this.publish();
  //   }

  //   decrease() {
  //     this.count -= 1;
  //     this.publish();
  //   }
  //
  //수정

  increase(step = 1) {
    this.count += step;
    this.publish();
  }

  decrease(step = 1) {
    this.count -= step;
    this.publish();
  }
}
```

여기까지

CounterStore, useObjectStore, 상속받은 useCounterStore, Counter, CountControl

모양이 아주 깔끔해졌다.

useDispatch, useSelector, BaseStore는 이제 쓰는곳 없어서 지운다.
